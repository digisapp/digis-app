// Improved MobileApp with proper touch handling and performance optimizations
// Fixes global touchmove prevention issues and adds feature detection

import React, { useEffect, useState, useRef, useCallback, lazy, Suspense } from 'react';
import { AnimatePresence, motion } from 'framer-motion';
import { devLog } from '../../utils/devLog';
import { realtimeService, EVENTS } from '../../services/realtimeService';
import { offlineQueue } from '../../services/offlineQueueService';
import MobileLoadingScreen from './MobileLoadingScreen';

// Lazy load heavy components
const MobileRouter = lazy(() => import('./MobileRouter'));
const MobileNav = lazy(() => import('./MobileNav'));
const MobileUIProvider = lazy(() => import('./MobileUIProvider'));
const FloatingActionButton = lazy(() => import('./FloatingActionButton'));
const MobileNetworkStatus = lazy(() => import('./MobileNetworkStatus'));
const MobileOfflineQueue = lazy(() => import('./MobileOfflineQueue'));

// Feature detection utilities
const detectDeviceCapabilities = () => {
  const ua = navigator.userAgent || '';
  const platform = navigator.platform || '';

  // Device detection
  const isIOS = /iPad|iPhone|iPod/.test(ua) || (platform === 'MacIntel' && navigator.maxTouchPoints > 1);
  const isAndroid = /Android/.test(ua);
  const isPWA = window.matchMedia('(display-mode: standalone)').matches;

  // Performance detection
  const memory = navigator.deviceMemory || 4; // GB
  const cores = navigator.hardwareConcurrency || 4;
  const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
  const effectiveType = connection?.effectiveType || '4g';

  // Feature detection
  const supportsHaptics = 'vibrate' in navigator;
  const supportsOffscreenCanvas = 'OffscreenCanvas' in window;
  const supportsIntersectionObserver = 'IntersectionObserver' in window;
  const supportsResizeObserver = 'ResizeObserver' in window;

  // Determine if low-end device
  const isLowEnd = memory < 4 || cores < 4 || effectiveType === 'slow-2g' || effectiveType === '2g';

  return {
    isIOS,
    isAndroid,
    isPWA,
    memory,
    cores,
    effectiveType,
    isLowEnd,
    supportsHaptics,
    supportsOffscreenCanvas,
    supportsIntersectionObserver,
    supportsResizeObserver
  };
};

// Feature flags based on device capabilities
const getFeatureFlags = (capabilities) => ({
  ENABLE_GLASS_EFFECTS: !capabilities.isLowEnd,
  ENABLE_HAPTICS: capabilities.supportsHaptics && !capabilities.isLowEnd,
  ENABLE_VIRTUAL_LISTS: true, // Always use for better performance
  ENABLE_IMAGE_COMPRESSION: true,
  ENABLE_OFFLINE_QUEUE: true,
  ENABLE_ANIMATIONS: !capabilities.isLowEnd && !window.matchMedia('(prefers-reduced-motion: reduce)').matches,
  ENABLE_HIGH_QUALITY_IMAGES: !capabilities.isLowEnd && capabilities.effectiveType !== '3g',
  ENABLE_AUTO_PLAY: !capabilities.isLowEnd,
  USE_LITE_THEME: capabilities.isLowEnd,
  MAX_CACHED_MESSAGES: capabilities.isLowEnd ? 50 : 200,
  MAX_CACHED_IMAGES: capabilities.isLowEnd ? 20 : 100
});

const MobileAppImproved = ({ user, onNavigate }) => {
  // State
  const [capabilities] = useState(() => detectDeviceCapabilities());
  const [featureFlags] = useState(() => getFeatureFlags(capabilities));
  const [isReady, setIsReady] = useState(false);
  const [currentView, setCurrentView] = useState('home');
  const [showSplash, setShowSplash] = useState(true);

  // Refs for touch handling
  const touchStartY = useRef(null);
  const touchStartX = useRef(null);
  const pullToRefreshRef = useRef(null);
  const isRefreshing = useRef(false);

  // Safe area handling for iOS
  useEffect(() => {
    if (capabilities.isIOS) {
      const updateSafeAreas = () => {
        const root = document.documentElement;
        const safeAreaInsets = {
          top: getComputedStyle(root).getPropertyValue('--sat') || '0px',
          bottom: getComputedStyle(root).getPropertyValue('--sab') || '0px',
          left: getComputedStyle(root).getPropertyValue('--sal') || '0px',
          right: getComputedStyle(root).getPropertyValue('--sar') || '0px'
        };

        // Update CSS variables
        root.style.setProperty('--safe-area-top', `env(safe-area-inset-top, ${safeAreaInsets.top})`);
        root.style.setProperty('--safe-area-bottom', `env(safe-area-inset-bottom, ${safeAreaInsets.bottom})`);
        root.style.setProperty('--safe-area-left', `env(safe-area-inset-left, ${safeAreaInsets.left})`);
        root.style.setProperty('--safe-area-right', `env(safe-area-inset-right, ${safeAreaInsets.right})`);

        devLog('Safe areas updated:', safeAreaInsets);
      };

      updateSafeAreas();

      // Update on orientation change
      window.addEventListener('orientationchange', updateSafeAreas);
      window.addEventListener('resize', updateSafeAreas);

      return () => {
        window.removeEventListener('orientationchange', updateSafeAreas);
        window.removeEventListener('resize', updateSafeAreas);
      };
    }
  }, [capabilities.isIOS]);

  // Initialize realtime service
  useEffect(() => {
    if (user?.uid) {
      realtimeService.init({
        userId: user.uid,
        token: localStorage.getItem('accessToken'),
        autoConnect: true
      });

      // Subscribe to important events
      const unsubscribers = [
        realtimeService.on(EVENTS.MESSAGE_NEW, (data) => {
          devLog('New message received:', data);
          // Handle new message
        }),
        realtimeService.on(EVENTS.CALL_INCOMING, (data) => {
          devLog('Incoming call:', data);
          // Handle incoming call
        })
      ];

      return () => {
        unsubscribers.forEach(unsub => unsub());
        realtimeService.disconnect();
      };
    }
  }, [user]);

  // Proper touch event handling (fixes scroll issues!)
  useEffect(() => {
    let rafId = null;

    const handleTouchStart = (e) => {
      // Only track for pull-to-refresh at top of page
      if (window.scrollY === 0) {
        touchStartY.current = e.touches[0].clientY;
        touchStartX.current = e.touches[0].clientX;
      }
    };

    const handleTouchMove = (e) => {
      // Don't interfere with normal scrolling!
      if (!touchStartY.current || isRefreshing.current) return;

      const touchY = e.touches[0].clientY;
      const touchX = e.touches[0].clientX;
      const deltaY = touchY - touchStartY.current;
      const deltaX = Math.abs(touchX - touchStartX.current);

      // Only trigger pull-to-refresh if:
      // 1. At top of page
      // 2. Pulling down (deltaY > 0)
      // 3. Vertical movement is greater than horizontal (not swiping)
      // 4. Pulled far enough (> 100px)
      if (window.scrollY === 0 && deltaY > 100 && deltaY > deltaX * 2) {
        if (!isRefreshing.current && pullToRefreshRef.current) {
          isRefreshing.current = true;

          // Visual feedback
          if (featureFlags.ENABLE_HAPTICS) {
            navigator.vibrate?.(10);
          }

          // Trigger refresh
          pullToRefreshRef.current();
        }
      }
    };

    const handleTouchEnd = () => {
      touchStartY.current = null;
      touchStartX.current = null;

      // Reset refreshing state after animation
      if (isRefreshing.current) {
        setTimeout(() => {
          isRefreshing.current = false;
        }, 1000);
      }
    };

    // Add touch listeners with passive flag for better scrolling performance
    document.addEventListener('touchstart', handleTouchStart, { passive: true });
    document.addEventListener('touchmove', handleTouchMove, { passive: true });
    document.addEventListener('touchend', handleTouchEnd, { passive: true });

    return () => {
      document.removeEventListener('touchstart', handleTouchStart);
      document.removeEventListener('touchmove', handleTouchMove);
      document.removeEventListener('touchend', handleTouchEnd);
      if (rafId) cancelAnimationFrame(rafId);
    };
  }, [featureFlags.ENABLE_HAPTICS]);

  // Handle pull-to-refresh
  const handleRefresh = useCallback(async () => {
    devLog('Pull to refresh triggered');

    // Perform refresh actions
    try {
      // Refresh data based on current view
      switch (currentView) {
        case 'messages':
          // Refresh messages
          break;
        case 'explore':
          // Refresh creators
          break;
        default:
          // General refresh
          break;
      }
    } catch (error) {
      devLog('Refresh error:', error);
    }
  }, [currentView]);

  // Set pull-to-refresh handler
  useEffect(() => {
    pullToRefreshRef.current = handleRefresh;
  }, [handleRefresh]);

  // Service worker registration for PWA
  useEffect(() => {
    if ('serviceWorker' in navigator && !capabilities.isLowEnd) {
      navigator.serviceWorker.register('/sw.js')
        .then(registration => {
          devLog('Service Worker registered:', registration);

          // Check for updates
          registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;

            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                // New service worker available
                devLog('New app version available');
                // Show update prompt
              }
            });
          });
        })
        .catch(error => {
          devLog('Service Worker registration failed:', error);
        });
    }
  }, [capabilities.isLowEnd]);

  // Hide splash screen
  useEffect(() => {
    const timer = setTimeout(() => {
      setShowSplash(false);
      setIsReady(true);
    }, 1500);

    return () => clearTimeout(timer);
  }, []);

  // Apply feature flags to document
  useEffect(() => {
    const root = document.documentElement;

    // Apply theme based on device capabilities
    if (featureFlags.USE_LITE_THEME) {
      root.classList.add('lite-theme');
      root.style.setProperty('--enable-glass', '0');
      root.style.setProperty('--enable-shadows', '0');
      root.style.setProperty('--enable-animations', '0');
    } else {
      root.style.setProperty('--enable-glass', '1');
      root.style.setProperty('--enable-shadows', '1');
      root.style.setProperty('--enable-animations', featureFlags.ENABLE_ANIMATIONS ? '1' : '0');
    }

    devLog('Feature flags applied:', featureFlags);
  }, [featureFlags]);

  // Splash screen
  if (showSplash) {
    return (
      <motion.div
        className="fixed inset-0 bg-gradient-to-br from-purple-600 to-pink-600 flex items-center justify-center"
        exit={{ opacity: 0 }}
        transition={{ duration: 0.5 }}
      >
        <motion.div
          initial={{ scale: 0.8, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          transition={{ duration: 0.5 }}
          className="text-white text-center"
        >
          <h1 className="text-4xl font-bold mb-2">Digis</h1>
          <p className="text-lg opacity-90">Connect with creators</p>
        </motion.div>
      </motion.div>
    );
  }

  return (
    <Suspense fallback={<MobileLoadingScreen />}>
      <MobileUIProvider featureFlags={featureFlags}>
        <div className="mobile-app-container">
          {/* Pull-to-refresh indicator */}
          <AnimatePresence>
            {isRefreshing.current && (
              <motion.div
                className="fixed top-0 left-0 right-0 z-50 flex justify-center pt-4"
                initial={{ y: -50, opacity: 0 }}
                animate={{ y: 0, opacity: 1 }}
                exit={{ y: -50, opacity: 0 }}
                style={{ paddingTop: 'var(--safe-area-top)' }}
              >
                <div className="bg-white rounded-full shadow-lg px-4 py-2">
                  <div className="w-5 h-5 border-2 border-purple-600 border-t-transparent rounded-full animate-spin" />
                </div>
              </motion.div>
            )}
          </AnimatePresence>

          {/* Network status (only if online/offline changes) */}
          <MobileNetworkStatus />

          {/* Main router */}
          <MobileRouter
            user={user}
            onNavigate={onNavigate}
            currentView={currentView}
            setCurrentView={setCurrentView}
            featureFlags={featureFlags}
          />

          {/* Bottom navigation */}
          <MobileNav
            currentView={currentView}
            onNavigate={(view) => {
              setCurrentView(view);
              onNavigate?.(view);
            }}
            isCreator={user?.is_creator}
            featureFlags={featureFlags}
          />

          {/* Floating action button (creator only) */}
          {user?.is_creator && (
            <FloatingActionButton
              onAction={(action) => {
                devLog('FAB action:', action);
                // Handle FAB actions
              }}
            />
          )}

          {/* Offline queue indicator */}
          <MobileOfflineQueue />
        </div>

        <style jsx>{`
          .mobile-app-container {
            min-height: 100vh;
            min-height: -webkit-fill-available;
            padding-top: var(--safe-area-top);
            padding-bottom: calc(80px + var(--safe-area-bottom));
            position: relative;
            overflow: hidden;
          }

          .lite-theme {
            --glass-opacity: 1;
            --glass-blur: 0;
            --shadow-strength: 0;
            --animation-duration: 0.1s;
          }

          @supports (padding: env(safe-area-inset-top)) {
            .mobile-app-container {
              padding-top: env(safe-area-inset-top);
              padding-bottom: calc(80px + env(safe-area-inset-bottom));
            }
          }
        `}</style>
      </MobileUIProvider>
    </Suspense>
  );
};

export default MobileAppImproved;